Question 1:- Why do we call JavaScript as dynamic language?
variable can change during runtime

Question 2:- how does JavaScript determine data types ?
data types depended on values assigned

Question 3:- What is typeof functions?
determine datatype in JavaScript uses typeof

Question 4:- How to check data type in JavaScript ?
using typeof

Question 5:- What are different datatypes in JavaScript ?
primitive :- String,number,null,Undefined,symbol,boolean
non-primitive/object type :- objects,array,date

Question 6:- Explain Undefined Data types ?
variable has been declare but value is not assigned

Question 7:- What is Null ?
null indicates absence of data. its not zero or empty. it is primitive datatype.

Question 8:- Differentiate between Null and Undefined ?
Undefined :-variable has been declare but value is not assigned
Null :-null indicates absence of data.

Question 9:- Explain Hoisting ?
check with hoisting.js

Question 10:- Are JavaScript initialization hoisted ?
No

Question 11:- What are global variables ?
those variables access through out document

Question 12:- What are the issues with Global variables ?
hard to debug

Question 13:- What happens when you declare variable with out VAR ?
it will become global variable
Question 14:- What is Use Strict ?
JavaScript's strict mode is a way to opt in to a restricted variant of JavaScript, thereby implicitly opting-out of "sloppy mode".

Question 15:- How to force developers to use Var keyword ?// strick

Question 16:- How can we handle Global Variables ?
Question 17:- How can we avoid Global variables ?
using Closures

Question 18:- What are Closures ?
check closure.js
Question 19:- Why do we need Closures ?
create self contain function and state and solve global variable problem
Question 20:- Explain IIFE ?
it is anonymous function it invoke immediately

Question 21:- What is the use of IIFE ?
solve name  collision 

Question 22:- What is name collision in global scope ?
name same variables or functions in same context

Question 23:- IIFE vs Normal Function?
normal function have name collision IIFE does not

Question 24:- What are design patterns ?
design patterns are time tested architecture. if we going to object uses singleton pattern

Question 25:- Which is the most used design pattern?
module design pattern or revealing module pattern

Question 26:- What is module Pattern and revealing module pattern ?
self contain independent components
provide encapsulation and abstraction

Question 27:- What are the various ways to create JavaScript objects?
four ways 1.object create normal way 2.use constructor 3.using class 4.Object.create()

Question 28:- How can we do inheritance in JavaScript ?
JavaScript uses object inheritance or prototype inheritance. inheritance done using prototype object

Question 29:- What is prototype in JavaScript ?
every object has prototype object

Question 30:- Explain Prototype chaining ?
means where one object inheritance to another object

Question 31:- What is Let Keyword?
block level scope, we can not re declare

Question 32:- Are Let variables hoisted ?
they are hoisted but not initialization

Question 33:- Explain Temporal Dead Zone ?
variables are declared before initialization access those variables in the state of period is TDZ.
those variables in memory but not have assigned values

Question 34:- Let vs Var
scope, declare, initialization

Question 35:- String Concatenation and Arithmetic puzzle
with "+" symbol to type caste

How to detect if caps lock is on using JavaScript?
use the getModifierState() method of the KeyboardEvent event object.

What is context API VS Redux?
Redux is a complete state manager capable of allowing an app to undo/redo actions and provides advanced developer tooling for debugging. 
Context API is designed as a dependency injection mechanism that allows making data available through the component tree without being manually passed

Question 36 :- What is class in ES6 ?
class is template of object

Question 37 :- So with class Keyword does it imply JavaScript is a OOP language ?
JS is a Prototype-based programming paradigm.
It is not an OOP language. But it has support for it. It has the class keyword, which is just a syntactic sugar over prototypes.

Question 38 :- Differentiate between class and normal function ?
class is template function is to perform a task
class are not hoisted and functions are hoisted
Functions can be overwritten, whereas classes can be extended, but not overwritten

Question 39 :- What is a Arrow function ?
ES6 feature and it is different from normal function

Question 40 :- Why do we use Arrow function ?
for readability and concise way to perform function task and we can able write single line to return function

Question 41 :- Differentiate between Arrow vs Normal Function ?
arrow function are syntactical shorter and more readability compares to normal function
In arrow functions can not bind this
No arguments object in arrow functions like normal functions passed parameters uses in function without pass args we use arguments
arrow functions not hoisted

Question 42 :- Does Arrow function create its own this ?
no

Question 43. Explain Synchronous execution ?
one by one execute function than it block until execute first one

Question 44. What is a call Stack ?
Question 45. What is a blocking call ?
Question 46. How to avoid blocking calls ?
Question 47. Explain Asynchronous execution ?
Question 48. Synch vs Asynch ?
Question 49. How can we do Asynch calls ?
Question 50. What is a thread ?
Question 51. Explain Multi-threading ?
Question 52. Is JavaScript Multi-threaded ?
Question 53. Then how does Settimeout run ?
Question 54. What is a WebAPI/Browser API ?
A Web API is an application programming interface for the Web. A Browser API can extend the functionality of a web browser

Question 55. What is a Event loop and callback queue?
Question 56. Eventloop and Callback code question?

Is Fetch API part of JavaScript Engine or JavaScript Runtime?

JavaScript runtime (Browser)

What will be the output of the following code snippet? (in operator)

const first = 2 in [1, 2]; // return false in array we have give index not value of index
const second = '2' in [0, 1, 2]; // return true
console.log("length" in first); // returns true (length is an Array property)
console.log(Symbol.iterator in first); // returns true
console.log(first, second); 

const myCar = { make: "Honda", model: "Accord", year: 1998 };
"make" in myCar; // returns true
"model" in myCar; // returns true

const color1 = new String("green"); // creating new string object
"length" in color1; // returns true

const color2 = "coral";
// generates an error (color2 is not a String object)
"length" in color2;

Canvas
Resolution dependent
No support for event handlers
Poor text rendering capabilities
You can save the resulting image as .png or .jpg
Well suited for graphic-intensive games

SVG
Resolution independent
Support for event handlers
Best suited for applications with large rendering areas (Google Maps)
Slow rendering if complex (anything that uses the DOM a lot will be slow)
Not suited for game applications

Execution context
 javascript is a synchronous single threaded language
 execution context has two components the first component is known as the memory component
 the second component is known as the code component 
 memory component contains variables and functions as the key value pairs and this code component is the place where whole javascript code is executed 
 memory component is also known as the variable environment and the code component is also known as the thread of execution

As soon as the whole JavaScript program is run,The global execution context is created.
It has two components, memory & code, as you know and it is created in two phases.
Phase 1, was the memory creation phase.
In the memory creation phase, we were allocating memory to all the variables and functions inside the global space.

And what we allocated these variables undefined
In case of functions literally it just stores the whole function. 
In the second phase,
the code execution phase, now the JS program is executed line by line, when code execute all local variables replaced
and created memory and code components inside code execution. 
in memory creation phase it store variable in function with undefined when parameter has value it will replaces undefined with value.
And it will now invoke the function, in the code execution phase, again this whole thing is run,
the task and return statement is executed.
In the return statement, we take back the control over here,
now function is populated with a new value which is coming from this function invocation, which was the result.

And suppose if there was a function invocation inside the function, you would have created an execution context INSIDE an execution context over here,
and maybe again an invocation so it can go to any deep level
call stack will handles everything to manage this execution context creation, deletion, and the control
Every time in the bottom of the stack we have our global execution context.
That means, whenever any JS program is run, this call stack is populated with this Global execution context.
Whenever a function is invoked, or a new execution context is created and pushed to stack,
we return the ans,Execution is popped out of the stack, and the control goes back to the global execution context, where it left.

Hoisting
The function statement and variable declared with var are accessible before they appear in the code
In hoisting the hoisted items are accessible in the scope they are declared in
Function expressions do not get hoisted
strict mode var not hoisted will give reference error but function will hoisted but inside function variables it will not hoisted
only declaration hoisted not assignment/initialization
execution context in memory phase Declarations will allocated to undefined

how function works in execution context
scope
syntax error vs reference error vs type error

const a; or const a;
            a=100;
we declared but not initialized look like SyntaxError: Missing initializer in const declaration
console.log(a) ReferenceError: Cannot access 'a' before initialization
let a=10
console.log(b) ReferenceError: b is not defined
reference error has two types one is not defined and second is not access before initialized
const a=10
 a=100
 console.log(a); TypeError: Assignment to constant variable
type error is when a value is not of the expected type

block: we need write multiple statements opn closed curly braces that is block

closure: function along with lexical scope bundle together forms a  closure

first class functions
function statement vs function expression vs function declaration
statement: function statement(){} function with name
expression: var expression = function(){} function acts as variable value or var a=function z(){} also called named anonymous function
major difference these two is hoisting. expression not hoisted
declaration: function statement also known as function declaration
anonymous function: function(){} function without name. does't have identity. it will use function as value
arrow function: ()=>{}
first class function: function can be passed as argument to another function
function are first class functions or citizens of first class objects

Higher Order Function: A function that accepts a function as an argument and/or returns a function as its value.
callback function: function ability to passed as argument to another function it is first class function. it make asynchronous operation
EventListeners
Eventloop: event loop is a single-threaded loop used to manage the order in which asynchronous callbacks are executed
It allows asynchronous code to run without blocking subsequent synchronous code from executing.
promises: it is a object which will be filled value for certain period of time until receive from asynchronous operation.
Promises are used to handle asynchronous operations in JavaScript. 
It provides a cleaner way to write asynchronous code using .then() and .catch() methods instead of nested callbacks
catch() will handle errors after catch() writing than() it will execute no mater what happens. in promise chaining we have to return in every than()

async await vs promise
async is keyword used before a function to create
async function will always return a promise 

await is keyword that can only use in async function

difference of promise and async


const p= new Promise((resolve,reject)=>{
    setTimeout(()=>{
      resolve("promise resolve afer 10 sec")
    },10000)
})

function getData(){
  p.than((res)=>console.log(res))
  console.log(" it will print before promise resolve")
}
getData()
when execute promise it will print after 10 sec but console.log will print before promise resolve
async and await was different it will print in both same time

async function handlePromise(){
console.log("hello")
 
 // this major difference
  const val = await p; // before code will execute when JS Engine see await it will wait to promise resolve
  console.log("print what ever text with promise value")
  console.log(val);

  const val2 = await p; // if write two time await it will print both at time
  console.log("print what ever text with promise value2")
  console.log(val2);
}
handlePromise()

what happens if two async function call different times wait

const p1 = new Promise((resolve,reject)=>{
    setTimeout(()=>{
      resolve("promise resolve after 10 sec")
    },10000)
})

const p2 = new Promise((resolve,reject)=>{
    setTimeout(()=>{
      resolve("promise resolve after 10 sec")
    },5000)
})

async function handlePromise(){
console.log("hello")
 
  const val = await p1; 
  console.log("print what ever text with promise value")
  console.log(val);

  const val2 = await p2; 
  console.log("print what ever text with promise value2")
  console.log(val2);
}
handlePromise()

it will not print after 5 sec's it gone it will print after 10 sec all at time 
async function await the all promises resolve because first await wait 10 sec 

if we reverse the timing p1 will 5 sec and p2 will 10 sec than it will print 5 sec promise will first than p2 will print after 10 sec

what happens behind scenes
 JS Engine waiting for promise to resolve than it will execute. this wrong statement when JS Engine waits browser will unresponsive

as soon as we call this handlePromise function will come inside your call stack right now it will executing all of this one by one
will log hello to the console after it will see that there is a await P1 over here
JavaScript does not wait for anything and this handle promise function is execution will suspend
and this will move out of call stack once this P1 is resolved then in only in it will move handlePromise to call stack and 
will start executing from where it left p1 5sec same on p2 10sec

p1 10sec and p2 5sec this scenario

hello will be printed immediately right now this P1 is 10 seconds so handle promise was executing it saw that P1 is not resolved yet
P1 will resolve after after 10sec than move to next line print then p2 will resolve in 5 sec so by the time it moves over
here after 10 seconds it sees that P2 is
already resolved than it will move to next line quickly print after 10 seconds it will
print

real world examples

using fetch api to get data
do use Async and await it will give more cleaner and wait for data to resolve

for error handling use try and catch block






