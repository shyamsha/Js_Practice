// File: src/types/grid.types.ts
export interface Column {
  id: string;
  field: string;
  headerName: string;
  width: number;
  minWidth?: number;
  maxWidth?: number;
  sortable?: boolean;
  filterable?: boolean;
  resizable?: boolean;
  type?: 'string' | 'number' | 'date' | 'boolean' | 'actions';
  renderCell?: (params: CellRenderParams) => React.ReactNode;
  valueFormatter?: (value: any) => string;
  align?: 'left' | 'center' | 'right';
  pinned?: 'left' | 'right' | false;
}

// File: src/hooks/useApi.ts
import { useState, useEffect } from 'react';
import { User, ApiResponse } from '@/types/api.types';

// Mock data generator
const generateUsers = (count: number): User[] => {
  const roles = ['Admin', 'Manager', 'Developer', 'Designer', 'Analyst'];
  const departments = ['Engineering', 'Design', 'Marketing', 'Sales', 'HR'];
  const statuses: ('active' | 'inactive')[] = ['active', 'inactive'];
  
  const names = [
    'Alice Johnson', 'Bob Smith', 'Carol Davis', 'David Wilson', 'Eve Brown',
    'Frank Miller', 'Grace Taylor', 'Henry Anderson', 'Ivy Thomas', 'Jack Jackson',
    'Kate White', 'Liam Harris', 'Mia Martin', 'Noah Thompson', 'Olivia Garcia',
    'Paul Rodriguez', 'Quinn Lewis', 'Rachel Lee', 'Sam Walker', 'Tina Hall'
  ];

  return Array.from({ length: count }, (_, i) => ({
    id: i + 1,
    name: names[i % names.length] + ` ${Math.floor(i / names.length) + 1}`,
    email: `user${i + 1}@example.com`,
    role: roles[Math.floor(Math.random() * roles.length)],
    department: departments[Math.floor(Math.random() * departments.length)],
    salary: Math.floor(Math.random() * 100000) + 40000,
    joinDate: new Date(2020 + Math.floor(Math.random() * 4), Math.floor(Math.random() * 12), Math.floor(Math.random() * 28)).toISOString().split('T')[0],
    status: statuses[Math.floor(Math.random() * statuses.length)],
    avatar: `https://avatar.vercel.sh/user${i + 1}.svg`
  }));
};

export function useApi() {
  const [data, setData] = useState<User[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const fetchUsers = async (page: number = 0, pageSize: number = 100) => {
    setLoading(true);
    setError(null);

    try {
      // Simulate API delay
      await new Promise(resolve => setTimeout(resolve, 1000));

      // Generate mock data
      const allUsers = generateUsers(1000);
      const startIndex = page * pageSize;
      const endIndex = startIndex + pageSize;
      const paginatedUsers = allUsers.slice(startIndex, endIndex);

      const response: ApiResponse<User> = {
        data: paginatedUsers,
        total: allUsers.length,
        page,
        pageSize,
        totalPages: Math.ceil(allUsers.length / pageSize)
      };

      setData(allUsers); // For demo, we'll load all data at once
      return response;
    } catch (err) {
      const message = err instanceof Error ? err.message : 'An error occurred';
      setError(message);
      throw err;
    } finally {
      setLoading(false);
    }
  };

  const updateUser = async (id: number, updates: Partial<User>) => {
    setLoading(true);
    setError(null);

    try {
      // Simulate API delay
      await new Promise(resolve => setTimeout(resolve, 500));

      setData(prevData => 
        prevData.map(user => 
          user.id === id ? { ...user, ...updates } : user
        )
      );
    } catch (err) {
      const message = err instanceof Error ? err.message : 'An error occurred';
      setError(message);
      throw err;
    } finally {
      setLoading(false);
    }
  };

  const deleteUser = async (id: number) => {
    setLoading(true);
    setError(null);

    try {
      // Simulate API delay
      await new Promise(resolve => setTimeout(resolve, 500));

      setData(prevData => prevData.filter(user => user.id !== id));
    } catch (err) {
      const message = err instanceof Error ? err.message : 'An error occurred';
      setError(message);
      throw err;
    } finally {
      setLoading(false);
    }
  };

  return {
    data,
    loading,
    error,
    fetchUsers,
    updateUser,
    deleteUser
  };
}

// File: src/contexts/ThemeContext.tsx
'use client';

import React, { createContext, useContext, useState, useEffect, ReactNode } from

export interface CellRenderParams {
  value: any;
  row: any;
  field: string;
  id: string;
}

export interface SortModel {
  field: string;
  sort: 'asc' | 'desc';
}

export interface FilterModel {
  [field: string]: {
    type: 'contains' | 'equals' | 'startsWith' | 'endsWith' | 'greaterThan' | 'lessThan';
    value: any;
  };
}

export interface PaginationState {
  page: number;
  pageSize: number;
  total: number;
}

export interface GridState {
  data: any[];
  filteredData: any[];
  columns: Column[];
  visibleColumns: string[];
  pinnedColumns: { left: string[]; right: string[] };
  sortModel: SortModel[];
  filterModel: FilterModel;
  selectedRows: Set<string>;
  pagination: PaginationState;
  loading: boolean;
  error: string | null;
  searchTerm: string;
  density: 'compact' | 'standard' | 'comfortable';
  columnOrder: string[];
}

export type GridAction =
  | { type: 'SET_DATA'; payload: any[] }
  | { type: 'SET_LOADING'; payload: boolean }
  | { type: 'SET_ERROR'; payload: string | null }
  | { type: 'SET_COLUMNS'; payload: Column[] }
  | { type: 'TOGGLE_COLUMN_VISIBILITY'; payload: string }
  | { type: 'REORDER_COLUMNS'; payload: string[] }
  | { type: 'RESIZE_COLUMN'; payload: { columnId: string; width: number } }
  | { type: 'PIN_COLUMN'; payload: { columnId: string; side: 'left' | 'right' | false } }
  | { type: 'SET_SORT_MODEL'; payload: SortModel[] }
  | { type: 'SET_FILTER_MODEL'; payload: FilterModel }
  | { type: 'TOGGLE_ROW_SELECTION'; payload: string }
  | { type: 'SELECT_ALL_ROWS'; payload: boolean }
  | { type: 'SET_PAGINATION'; payload: Partial<PaginationState> }
  | { type: 'SET_SEARCH_TERM'; payload: string }
  | { type: 'SET_DENSITY'; payload: 'compact' | 'standard' | 'comfortable' }
  | { type: 'APPLY_FILTERS' }
  | { type: 'APPLY_SORT' };

// File: src/types/api.types.ts
export interface User {
  id: number;
  name: string;
  email: string;
  role: string;
  department: string;
  salary: number;
  joinDate: string;
  status: 'active' | 'inactive';
  avatar?: string;
}

export interface ApiResponse<T> {
  data: T[];
  total: number;
  page: number;
  pageSize: number;
  totalPages: number;
}

// File: src/utils/gridHelpers.ts
import { FilterModel, SortModel } from '@/types/grid.types';

export const applyFilters = (data: any[], filterModel: FilterModel, searchTerm: string): any[] => {
  let filteredData = [...data];

  // Apply global search
  if (searchTerm) {
    filteredData = filteredData.filter(row =>
      Object.values(row).some(value =>
        String(value).toLowerCase().includes(searchTerm.toLowerCase())
      )
    );
  }

  // Apply column filters
  Object.entries(filterModel).forEach(([field, filter]) => {
    if (filter.value !== undefined && filter.value !== '') {
      filteredData = filteredData.filter(row => {
        const cellValue = row[field];
        const filterValue = filter.value;

        switch (filter.type) {
          case 'contains':
            return String(cellValue).toLowerCase().includes(String(filterValue).toLowerCase());
          case 'equals':
            return cellValue === filterValue;
          case 'startsWith':
            return String(cellValue).toLowerCase().startsWith(String(filterValue).toLowerCase());
          case 'endsWith':
            return String(cellValue).toLowerCase().endsWith(String(filterValue).toLowerCase());
          case 'greaterThan':
            return Number(cellValue) > Number(filterValue);
          case 'lessThan':
            return Number(cellValue) < Number(filterValue);
          default:
            return true;
        }
      });
    }
  });

  return filteredData;
};

export const applySorting = (data: any[], sortModel: SortModel[]): any[] => {
  if (sortModel.length === 0) return data;

  return [...data].sort((a, b) => {
    for (const sort of sortModel) {
      const { field, sort: direction } = sort;
      let valueA = a[field];
      let valueB = b[field];

      // Handle different data types
      if (typeof valueA === 'string' && typeof valueB === 'string') {
        valueA = valueA.toLowerCase();
        valueB = valueB.toLowerCase();
      }

      if (valueA < valueB) {
        return direction === 'asc' ? -1 : 1;
      }
      if (valueA > valueB) {
        return direction === 'asc' ? 1 : -1;
      }
    }
    return 0;
  });
};

export const exportToCSV = (data: any[], columns: any[], filename: string = 'data.csv') => {
  const headers = columns.map(col => col.headerName).join(',');
  const rows = data.map(row =>
    columns.map(col => {
      const value = row[col.field];
      return typeof value === 'string' && value.includes(',') ? `"${value}"` : value;
    }).join(',')
  );

  const csvContent = [headers, ...rows].join('\n');
  const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
  const link = document.createElement('a');
  const url = URL.createObjectURL(blob);
  
  link.setAttribute('href', url);
  link.setAttribute('download', filename);
  link.style.visibility = 'hidden';
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
};

// File: src/hooks/useLocalStorage.ts
import { useState, useEffect } from 'react';

export function useLocalStorage<T>(key: string, initialValue: T) {
  const [storedValue, setStoredValue] = useState<T>(() => {
    if (typeof window === 'undefined') {
      return initialValue;
    }
    try {
      const item = window.localStorage.getItem(key);
      return item ? JSON.parse(item) : initialValue;
    } catch (error) {
      console.error(`Error reading localStorage key "${key}":`, error);
      return initialValue;
    }
  });

  const setValue = (value: T | ((val: T) => T)) => {
    try {
      const valueToStore = value instanceof Function ? value(storedValue) : value;
      setStoredValue(valueToStore);
      if (typeof window !== 'undefined') {
        window.localStorage.setItem(key, JSON.stringify(valueToStore));
      }
    } catch (error) {
      console.error(`Error setting localStorage key "${key}":`, error);
    }
  };

  return [storedValue, setValue] as const;
}

// File: src/hooks/useVirtualScroll.ts
import { useState, useEffect, useMemo } from 'react';

interface UseVirtualScrollOptions {
  itemHeight: number;
  containerHeight: number;
  items: any[];
  overscan?: number;
}

export function useVirtualScroll({
  itemHeight,
  containerHeight,
  items,
  overscan = 5
}: UseVirtualScrollOptions) {
  const [scrollTop, setScrollTop] = useState(0);

  const visibleRange = useMemo(() => {
    const visibleCount = Math.ceil(containerHeight / itemHeight);
    const startIndex = Math.floor(scrollTop / itemHeight);
    const endIndex = Math.min(startIndex + visibleCount + overscan, items.length - 1);

    return {
      start: Math.max(0, startIndex - overscan),
      end: endIndex,
      visibleItems: items.slice(
        Math.max(0, startIndex - overscan),
        endIndex + 1
      )
    };
  }, [scrollTop, itemHeight, containerHeight, items, overscan]);

  const totalHeight = items.length * itemHeight;
  const offsetY = visibleRange.start * itemHeight;

  return {
    visibleRange,
    totalHeight,
    offsetY,
    setScrollTop
  };
}

// File: src/contexts/DataGridContext.tsx
'use client';

import React, { createContext, useContext, useReducer, useCallback, ReactNode } from 'react';
import { GridState, GridAction, Column, SortModel, FilterModel } from '@/types/grid.types';
import { applyFilters, applySorting } from '@/utils/gridHelpers';

const initialState: GridState = {
  data: [],
  filteredData: [],
  columns: [],
  visibleColumns: [],
  pinnedColumns: { left: [], right: [] },
  sortModel: [],
  filterModel: {},
  selectedRows: new Set(),
  pagination: { page: 0, pageSize: 100, total: 0 },
  loading: false,
  error: null,
  searchTerm: '',
  density: 'standard',
  columnOrder: [],
};

function gridReducer(state: GridState, action: GridAction): GridState {
  switch (action.type) {
    case 'SET_DATA':
      return {
        ...state,
        data: action.payload,
        filteredData: applyFilters(action.payload, state.filterModel, state.searchTerm),
        pagination: { ...state.pagination, total: action.payload.length }
      };

    case 'SET_LOADING':
      return { ...state, loading: action.payload };

    case 'SET_ERROR':
      return { ...state, error: action.payload };

    case 'SET_COLUMNS':
      return {
        ...state,
        columns: action.payload,
        visibleColumns: action.payload.map(col => col.id),
        columnOrder: action.payload.map(col => col.id)
      };

    case 'TOGGLE_COLUMN_VISIBILITY':
      const isVisible = state.visibleColumns.includes(action.payload);
      return {
        ...state,
        visibleColumns: isVisible
          ? state.visibleColumns.filter(id => id !== action.payload)
          : [...state.visibleColumns, action.payload]
      };

    case 'REORDER_COLUMNS':
      return { ...state, columnOrder: action.payload };

    case 'RESIZE_COLUMN':
      return {
        ...state,
        columns: state.columns.map(col =>
          col.id === action.payload.columnId
            ? { ...col, width: action.payload.width }
            : col
        )
      };

    case 'PIN_COLUMN':
      const { columnId, side } = action.payload;
      let newPinnedColumns = { ...state.pinnedColumns };
      
      // Remove from both sides first
      newPinnedColumns.left = newPinnedColumns.left.filter(id => id !== columnId);
      newPinnedColumns.right = newPinnedColumns.right.filter(id => id !== columnId);
      
      // Add to the specified side
      if (side === 'left') {
        newPinnedColumns.left.push(columnId);
      } else if (side === 'right') {
        newPinnedColumns.right.push(columnId);
      }

      return { ...state, pinnedColumns: newPinnedColumns };

    case 'SET_SORT_MODEL':
      const sortedData = applySorting(state.filteredData, action.payload);
      return {
        ...state,
        sortModel: action.payload,
        filteredData: sortedData
      };

    case 'SET_FILTER_MODEL':
      return { ...state, filterModel: action.payload };

    case 'TOGGLE_ROW_SELECTION':
      const newSelectedRows = new Set(state.selectedRows);
      if (newSelectedRows.has(action.payload)) {
        newSelectedRows.delete(action.payload);
      } else {
        newSelectedRows.add(action.payload);
      }
      return { ...state, selectedRows: newSelectedRows };

    case 'SELECT_ALL_ROWS':
      return {
        ...state,
        selectedRows: action.payload
          ? new Set(state.filteredData.map(row => String(row.id)))
          : new Set()
      };

    case 'SET_PAGINATION':
      return {
        ...state,
        pagination: { ...state.pagination, ...action.payload }
      };

    case 'SET_SEARCH_TERM':
      const filteredWithSearch = applyFilters(state.data, state.filterModel, action.payload);
      const sortedWithSearch = applySorting(filteredWithSearch, state.sortModel);
      return {
        ...state,
        searchTerm: action.payload,
        filteredData: sortedWithSearch,
        pagination: { ...state.pagination, page: 0, total: filteredWithSearch.length }
      };

    case 'SET_DENSITY':
      return { ...state, density: action.payload };

    case 'APPLY_FILTERS':
      const filtered = applyFilters(state.data, state.filterModel, state.searchTerm);
      const sorted = applySorting(filtered, state.sortModel);
      return {
        ...state,
        filteredData: sorted,
        pagination: { ...state.pagination, page: 0, total: filtered.length }
      };

    case 'APPLY_SORT':
      return {
        ...state,
        filteredData: applySorting(state.filteredData, state.sortModel)
      };

    default:
      return state;
  }
}

interface DataGridContextType {
  state: GridState;
  dispatch: React.Dispatch<GridAction>;
  actions: {
    setData: (data: any[]) => void;
    setColumns: (columns: Column[]) => void;
    toggleColumnVisibility: (columnId: string) => void;
    reorderColumns: (newOrder: string[]) => void;
    resizeColumn: (columnId: string, width: number) => void;
    pinColumn: (columnId: string, side: 'left' | 'right' | false) => void;
    setSortModel: (sortModel: SortModel[]) => void;
    setFilterModel: (filterModel: FilterModel) => void;
    toggleRowSelection: (rowId: string) => void;
    selectAllRows: (selected: boolean) => void;
    setPagination: (pagination: Partial<GridState['pagination']>) => void;
    setSearchTerm: (term: string) => void;
    setDensity: (density: GridState['density']) => void;
    setLoading: (loading: boolean) => void;
    setError: (error: string | null) => void;
  };
}

const DataGridContext = createContext<DataGridContextType | null>(null);

export function DataGridProvider({ children }: { children: ReactNode }) {
  const [state, dispatch] = useReducer(gridReducer, initialState);

  const actions = {
    setData: useCallback((data: any[]) => {
      dispatch({ type: 'SET_DATA', payload: data });
    }, []),

    setColumns: useCallback((columns: Column[]) => {
      dispatch({ type: 'SET_COLUMNS', payload: columns });
    }, []),

    toggleColumnVisibility: useCallback((columnId: string) => {
      dispatch({ type: 'TOGGLE_COLUMN_VISIBILITY', payload: columnId });
    }, []),

    reorderColumns: useCallback((newOrder: string[]) => {
      dispatch({ type: 'REORDER_COLUMNS', payload: newOrder });
    }, []),

    resizeColumn: useCallback((columnId: string, width: number) => {
      dispatch({ type: 'RESIZE_COLUMN', payload: { columnId, width } });
    }, []),

    pinColumn: useCallback((columnId: string, side: 'left' | 'right' | false) => {
      dispatch({ type: 'PIN_COLUMN', payload: { columnId, side } });
    }, []),

    setSortModel: useCallback((sortModel: SortModel[]) => {
      dispatch({ type: 'SET_SORT_MODEL', payload: sortModel });
    }, []),

    setFilterModel: useCallback((filterModel: FilterModel) => {
      dispatch({ type: 'SET_FILTER_MODEL', payload: filterModel });
      dispatch({ type: 'APPLY_FILTERS' });
    }, []),

    toggleRowSelection: useCallback((rowId: string) => {
      dispatch({ type: 'TOGGLE_ROW_SELECTION', payload: rowId });
    }, []),

    selectAllRows: useCallback((selected: boolean) => {
      dispatch({ type: 'SELECT_ALL_ROWS', payload: selected });
    }, []),

    setPagination: useCallback((pagination: Partial<GridState['pagination']>) => {
      dispatch({ type: 'SET_PAGINATION', payload: pagination });
    }, []),

    setSearchTerm: useCallback((term: string) => {
      dispatch({ type: 'SET_SEARCH_TERM', payload: term });
    }, []),

    setDensity: useCallback((density: GridState['density']) => {
      dispatch({ type: 'SET_DENSITY', payload: density });
    }, []),

    setLoading: useCallback((loading: boolean) => {
      dispatch({ type: 'SET_LOADING', payload: loading });
    }, []),

    setError: useCallback((error: string | null) => {
      dispatch({ type: 'SET_ERROR', payload: error });
    }, [])
  };

  return (
    <DataGridContext.Provider value={{ state, dispatch, actions }}>
      {children}
    </DataGridContext.Provider>
  );
}

export function useDataGrid() {
  const context = useContext(DataGridContext);
  if (!context) {
    throw new Error('useDataGrid must be used within a DataGridProvider');
  }
  return context;
}

// File: src/components/ui/Button.tsx
import React from 'react';

interface ButtonProps extends React.ButtonHTMLAttributes<HTMLButtonElement> {
  variant?: 'primary' | 'secondary' | 'ghost' | 'danger';
  size?: 'sm' | 'md' | 'lg';
  children: React.ReactNode;
}

export function Button({ 
  variant = 'primary', 
  size = 'md', 
  className = '', 
  children, 
  ...props 
}: ButtonProps) {
  const baseClasses = 'inline-flex items-center justify-center font-medium transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-offset-2 disabled:opacity-50 disabled:pointer-events-none';
  
  const variants = {
    primary: 'bg-blue-600 text-white hover:bg-blue-700 focus-visible:ring-blue-600',
    secondary: 'bg-gray-200 text-gray-900 hover:bg-gray-300 focus-visible:ring-gray-500',
    ghost: 'hover:bg-gray-100 text-gray-700 focus-visible:ring-gray-500',
    danger: 'bg-red-600 text-white hover:bg-red-700 focus-visible:ring-red-600'
  };

  const sizes = {
    sm: 'h-8 px-3 text-sm rounded-md',
    md: 'h-10 px-4 py-2 rounded-md',
    lg: 'h-12 px-6 text-lg rounded-lg'
  };

  return (
    <button
      className={`${baseClasses} ${variants[variant]} ${sizes[size]} ${className}`}
      {...props}
    >
      {children}
    </button>
  );
}

// File: src/components/ui/Input.tsx
import React from 'react';

interface InputProps extends React.InputHTMLAttributes<HTMLInputElement> {
  label?: string;
  error?: string;
}

export function Input({ label, error, className = '', ...props }: InputProps) {
  return (
    <div className="flex flex-col space-y-1">
      {label && (
        <label className="text-sm font-medium text-gray-700">
          {label}
        </label>
      )}
      <input
        className={`px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500 ${
          error ? 'border-red-500' : ''
        } ${className}`}
        {...props}
      />
      {error && (
        <span className="text-sm text-red-600">{error}</span>
      )}
    </div>
  );
}

// File: src/components/ui/Select.tsx
import React from 'react';

interface SelectProps extends React.SelectHTMLAttributes<HTMLSelectElement> {
  label?: string;
  options: { value: string | number; label: string }[];
}

export function Select({ label, options, className = '', ...props }: SelectProps) {
  return (
    <div className="flex flex-col space-y-1">
      {label && (
        <label className="text-sm font-medium text-gray-700">
          {label}
        </label>
      )}
      <select
        className={`px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500 ${className}`}
        {...props}
      >
        {options.map((option) => (
          <option key={option.value} value={option.value}>
            {option.label}
          </option>
        ))}
      </select>
    </div>
  );
}

// File: src/components/DataGrid/DataGridCell.tsx
import React from 'react';
import { Column, CellRenderParams } from '@/types/grid.types';

interface DataGridCellProps {
  column: Column;
  row: any;
  value: any;
  isSelected: boolean;
  isEditing: boolean;
  onEdit: (field: string, value: any) => void;
  density: 'compact' | 'standard' | 'comfortable';
}

export function DataGridCell({
  column,
  row,
  value,
  isSelected,
  isEditing,
  onEdit,
  density
}: DataGridCellProps) {
  const [editValue, setEditValue] = React.useState(value);
  const [isEditMode, setIsEditMode] = React.useState(false);

  const cellParams: CellRenderParams = {
    value,
    row,
    field: column.field,
    id: row.id
  };

  const handleDoubleClick = () => {
    if (column.field !== 'actions' && column.field !== 'select') {
      setIsEditMode(true);
      setEditValue(value);
    }
  };

  const handleKeyDown = (e: React.KeyboardEvent) => {
    if (e.key === 'Enter') {
      onEdit(column.field, editValue);
      setIsEditMode(false);
    } else if (e.key === 'Escape') {
      setEditValue(value);
      setIsEditMode(false);
    }
  };

  const handleBlur = () => {
    onEdit(column.field, editValue);
    setIsEditMode(false);
  };

  const densityClasses = {
    compact: 'py-1 px-2',
    standard: 'py-2 px-3',
    comfortable: 'py-3 px-4'
  };

  const alignClasses = {
    left: 'text-left',
    center: 'text-center',
    right: 'text-right'
  };

  let cellContent;

  if (column.renderCell) {
    cellContent = column.renderCell(cellParams);
  } else if (isEditMode) {
    cellContent = (
      <input
        type="text"
        value={editValue}
        onChange={(e) => setEditValue(e.target.value)}
        onKeyDown={handleKeyDown}
        onBlur={handleBlur}
        className="w-full bg-transparent border-none outline-none"
        autoFocus
      />
    );
  } else {
    cellContent = column.valueFormatter ? column.valueFormatter(value) : String(value || '');
  }

  return (
    <td
      className={`
        border-r border-gray-200 truncate
        ${densityClasses[density]}
        ${alignClasses[column.align || 'left']}
        ${isSelected ? 'bg-blue-50' : 'hover:bg-gray-50'}
        ${isEditMode ? 'bg-blue-50' : ''}
      `}
      style={{ width: column.width, minWidth: column.minWidth, maxWidth: column.maxWidth }}
      onDoubleClick={handleDoubleClick}
    >
      {cellContent}
    </td>
  );
}

// File: src/components/DataGrid/DataGridRow.tsx
import React from 'react';
import { Column } from '@/types/grid.types';
import { DataGridCell } from './DataGridCell';

interface DataGridRowProps {
  row: any;
  columns: Column[];
  isSelected: boolean;
  onRowClick: (rowId: string) => void;
  onEdit: (rowId: string, field: string, value: any) => void;
  density: 'compact' | 'standard' | 'comfortable';
  showCheckbox: boolean;
}

export function DataGridRow({
  row,
  columns,
  isSelected,
  onRowClick,
  onEdit,
  density,
  showCheckbox
}: DataGridRowProps) {
  const handleEdit = (field: string, value: any) => {
    onEdit(row.id, field, value);
  };

  const densityClasses = {
    compact: 'h-8',
    standard: 'h-12',
    comfortable: 'h-16'
  };

  return (
    <tr
      className={`
        border-b border-gray-200 cursor-pointer transition-colors
        ${densityClasses[density]}
        ${isSelected ? 'bg-blue-50' : 'hover:bg-gray-50'}
      `}
      onClick={() => onRowClick(String(row.id))}
    >
      {showCheckbox && (
        <td className="w-12 px-3">
          <input
            type="checkbox"
            checked={isSelected}
            onChange={() => onRowClick(String(row.id))}
            className="w-4 h-4 text-blue-600 border-gray-300 rounded focus:ring-blue-500"
            onClick={(e) => e.stopPropagation()}
          />
        </td>
      )}
      {columns.map((column) => (
        <DataGridCell
          key={column.id}
          column={column}
          row={row}
          value={row[column.field]}
          isSelected={isSelected}
          isEditing={false}
          onEdit={handleEdit}
          density={density}
        />
      ))}
    </tr>
  );
}

// Continue with the rest of the implementation...

// File: src/components/DataGrid/DataGridHeader.tsx
import React, { useState } from 'react';
import { Column, SortModel } from '@/types/grid.types';

interface DataGridHeaderProps {
  columns: Column[];
  sortModel: SortModel[];
  onSort: (field: string) => void;
  onResize: (columnId: string, width: number) => void;
  showCheckbox: boolean;
  allSelected: boolean;
  onSelectAll: (selected: boolean) => void;
  onColumnMenu: (columnId: string, event: React.MouseEvent) => void;
}

export function DataGridHeader({
  columns,
  sortModel,
  onSort,
  onResize,
  showCheckbox,
  allSelected,
  onSelectAll,
  onColumnMenu
}: DataGridHeaderProps) {
  const [resizing, setResizing] = useState<{ columnId: string; startX: number; startWidth: number } | null>(null);

  const handleMouseDown = (e: React.MouseEvent, column: Column) => {
    if (!column.resizable) return;
    
    e.preventDefault();
    setResizing({
      columnId: column.id,
      startX: e.clientX,
      startWidth: column.width
    });
  };

  const handleMouseMove = React.useCallback((e: MouseEvent) => {
    if (!resizing) return;

    const diff = e.clientX - resizing.startX;
    const newWidth = Math.max(50, resizing.startWidth + diff);
    onResize(resizing.columnId, newWidth);
  }, [resizing, onResize]);

  const handleMouseUp = React.useCallback(() => {
    setResizing(null);
  }, []);

  React.useEffect(() => {
    if (resizing) {
      document.addEventListener('mousemove', handleMouseMove);
      document.addEventListener('mouseup', handleMouseUp);
      return () => {
        document.removeEventListener('mousemove', handleMouseMove);
        document.removeEventListener('mouseup', handleMouseUp);
      };
    }
  }, [resizing, handleMouseMove, handleMouseUp]);

  const getSortIcon = (field: string) => {
    const sort = sortModel.find(s => s.field === field);
    if (!sort) return '‚ÜïÔ∏è';
    return sort.sort === 'asc' ? '‚Üë' : '‚Üì';
  };

  return (
    <thead className="bg-gray-50 sticky top-0 z-10">
      <tr>
        {showCheckbox && (
          <th className="w-12 px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
            <input
              type="checkbox"
              checked={allSelected}
              onChange={(e) => onSelectAll(e.target.checked)}
              className="w-4 h-4 text-blue-600 border-gray-300 rounded focus:ring-blue-500"
            />
          </th>
        )}
        {columns.map((column) => (
          <th
            key={column.id}
            className="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider border-r border-gray-200 relative group select-none"
            style={{ width: column.width, minWidth: column.minWidth, maxWidth: column.maxWidth }}
          >
            <div className="flex items-center justify-between">
              <div
                className={`flex items-center space-x-1 cursor-pointer ${column.sortable ? 'hover:text-gray-700' : ''}`}
                onClick={() => column.sortable && onSort(column.field)}
              >
                <span className="truncate">{column.headerName}</span>
                {column.sortable && (
                  <span className="text-gray-400 group-hover:text-gray-600">
                    {getSortIcon(column.field)}
                  </span>
                )}
              </div>
              
              <button
                onClick={(e) => onColumnMenu(column.id, e)}
                className="opacity-0 group-hover:opacity-100 p-1 hover:bg-gray-200 rounded"
              >
                ‚ãÆ
              </button>
            </div>
            
            {column.resizable && (
              <div
                className="absolute right-0 top-0 w-1 h-full cursor-col-resize hover:bg-blue-400 group-hover:bg-gray-300"
                onMouseDown={(e) => handleMouseDown(e, column)}
              />
            )}
          </th>
        ))}
      </tr>
    </thead>
  );
}

// File: src/components/DataGrid/Pagination.tsx
import React from 'react';
import { PaginationState } from '@/types/grid.types';
import { Button } from '@/components/ui/Button';
import { Select } from '@/components/ui/Select';

interface PaginationProps {
  pagination: PaginationState;
  onPageChange: (page: number) => void;
  onPageSizeChange: (pageSize: number) => void;
}

export function Pagination({ pagination, onPageChange, onPageSizeChange }: PaginationProps) {
  const { page, pageSize, total } = pagination;
  const totalPages = Math.ceil(total / pageSize);
  const startItem = page * pageSize + 1;
  const endItem = Math.min((page + 1) * pageSize, total);

  const pageSizeOptions = [
    { value: 10, label: '10' },
    { value: 25, label: '25' },
    { value: 50, label: '50' },
    { value: 100, label: '100' },
    { value: 200, label: '200' }
  ];

  const getVisiblePageNumbers = () => {
    const delta = 2;
    const range = [];
    const rangeWithDots = [];

    for (let i = Math.max(2, page - delta); i <= Math.min(totalPages - 1, page + delta); i++) {
      range.push(i);
    }

    if (page - delta > 2) {
      rangeWithDots.push(1, '...');
    } else {
      rangeWithDots.push(1);
    }

    rangeWithDots.push(...range);

    if (page + delta < totalPages - 1) {
      rangeWithDots.push('...', totalPages);
    } else {
      rangeWithDots.push(totalPages);
    }

    return rangeWithDots;
  };

  if (total === 0) {
    return (
      <div className="flex items-center justify-between px-4 py-3 bg-white border-t border-gray-200">
        <div className="text-sm text-gray-700">No data to display</div>
      </div>
    );
  }

  return (
    <div className="flex items-center justify-between px-4 py-3 bg-white border-t border-gray-200">
      <div className="flex items-center space-x-4">
        <div className="text-sm text-gray-700">
          Showing {startItem} to {endItem} of {total} results
        </div>
        <div className="flex items-center space-x-2">
          <span className="text-sm text-gray-700">Rows per page:</span>
          <Select
            value={pageSize}
            onChange={(e) => onPageSizeChange(Number(e.target.value))}
            options={pageSizeOptions}
            className="w-20"
          />
        </div>
      </div>

      <div className="flex items-center space-x-2">
        <Button
          variant="ghost"
          size="sm"
          onClick={() => onPageChange(0)}
          disabled={page === 0}
        >
          First
        </Button>
        <Button
          variant="ghost"
          size="sm"
          onClick={() => onPageChange(page - 1)}
          disabled={page === 0}
        >
          Previous
        </Button>

        <div className="flex space-x-1">
          {getVisiblePageNumbers().map((pageNum, index) => (
            <React.Fragment key={index}>
              {pageNum === '...' ? (
                <span className="px-3 py-1 text-gray-500">...</span>
              ) : (
                <Button
                  variant={pageNum - 1 === page ? 'primary' : 'ghost'}
                  size="sm"
                  onClick={() => onPageChange(Number(pageNum) - 1)}
                  className="w-10"
                >
                  {pageNum}
                </Button>
              )}
            </React.Fragment>
          ))}
        </div>

        <Button
          variant="ghost"
          size="sm"
          onClick={() => onPageChange(page + 1)}
          disabled={page >= totalPages - 1}
        >
          Next
        </Button>
        <Button
          variant="ghost"
          size="sm"
          onClick={() => onPageChange(totalPages - 1)}
          disabled={page >= totalPages - 1}
        >
          Last
        </Button>
      </div>
    </div>
  );
}

// File: src/components/DataGrid/FilterPanel.tsx
import React, { useState } from 'react';
import { Column, FilterModel } from '@/types/grid.types';
import { Input } from '@/components/ui/Input';
import { Select } from '@/components/ui/Select';
import { Button } from '@/components/ui/Button';

interface FilterPanelProps {
  columns: Column[];
  filterModel: FilterModel;
  onFilterChange: (filterModel: FilterModel) => void;
  isOpen: boolean;
  onClose: () => void;
}

export function FilterPanel({ columns, filterModel, onFilterChange, isOpen, onClose }: FilterPanelProps) {
  const [localFilters, setLocalFilters] = useState<FilterModel>(filterModel);

  const filterTypes = [
    { value: 'contains', label: 'Contains' },
    { value: 'equals', label: 'Equals' },
    { value: 'startsWith', label: 'Starts with' },
    { value: 'endsWith', label: 'Ends with' },
    { value: 'greaterThan', label: 'Greater than' },
    { value: 'lessThan', label: 'Less than' }
  ];

  const handleFilterChange = (field: string, type: string, value: any) => {
    const newFilters = {
      ...localFilters,
      [field]: { type: type as any, value }
    };
    setLocalFilters(newFilters);
  };

  const handleApplyFilters = () => {
    onFilterChange(localFilters);
    onClose();
  };

  const handleClearFilters = () => {
    setLocalFilters({});
    onFilterChange({});
    onClose();
  };

  const filterable = columns.filter(col => col.filterable !== false);

  if (!isOpen) return null;

  return (
    <div className="absolute top-full left-0 right-0 bg-white border border-gray-200 shadow-lg z-20 p-4">
      <div className="flex items-center justify-between mb-4">
        <h3 className="text-lg font-semibold">Filters</h3>
        <button onClick={onClose} className="text-gray-500 hover:text-gray-700">
          ‚úï
        </button>
      </div>

      <div className="space-y-4 max-h-96 overflow-y-auto">
        {filterable.map((column) => (
          <div key={column.id} className="flex items-center space-x-2">
            <div className="w-32 text-sm font-medium text-gray-700">
              {column.headerName}
            </div>
            <Select
              value={localFilters[column.field]?.type || 'contains'}
              onChange={(e) => handleFilterChange(
                column.field, 
                e.target.value, 
                localFilters[column.field]?.value || ''
              )}
              options={filterTypes}
              className="w-32"
            />
            <Input
              value={localFilters[column.field]?.value || ''}
              onChange={(e) => handleFilterChange(
                column.field,
                localFilters[column.field]?.type || 'contains',
                e.target.value
              )}
              placeholder="Filter value"
              className="flex-1"
            />
          </div>
        ))}
      </div>

      <div className="flex justify-end space-x-2 mt-4 pt-4 border-t border-gray-200">
        <Button variant="ghost" onClick={handleClearFilters}>
          Clear All
        </Button>
        <Button onClick={handleApplyFilters}>
          Apply Filters
        </Button>
      </div>
    </div>
  );
}

// File: src/components/DataGrid/ColumnManager.tsx
import React, { useState } from 'react';
import { Column } from '@/types/grid.types';
import { Button } from '@/components/ui/Button';

interface ColumnManagerProps {
  columns: Column[];
  visibleColumns: string[];
  pinnedColumns: { left: string[]; right: string[] };
  onToggleVisibility: (columnId: string) => void;
  onPinColumn: (columnId: string, side: 'left' | 'right' | false) => void;
  onReorderColumns: (newOrder: string[]) => void;
  isOpen: boolean;
  onClose: () => void;
}

export function ColumnManager({
  columns,
  visibleColumns,
  pinnedColumns,
  onToggleVisibility,
  onPinColumn,
  onReorderColumns,
  isOpen,
  onClose
}: ColumnManagerProps) {
  const [draggedColumn, setDraggedColumn] = useState<string | null>(null);

  const handleDragStart = (e: React.DragEvent, columnId: string) => {
    setDraggedColumn(columnId);
    e.dataTransfer.effectAllowed = 'move';
  };

  const handleDragOver = (e: React.DragEvent) => {
    e.preventDefault();
    e.dataTransfer.dropEffect = 'move';
  };

  const handleDrop = (e: React.DragEvent, targetColumnId: string) => {
    e.preventDefault();
    
    if (!draggedColumn || draggedColumn === targetColumnId) return;

    const currentOrder = columns.map(col => col.id);
    const draggedIndex = currentOrder.indexOf(draggedColumn);
    const targetIndex = currentOrder.indexOf(targetColumnId);

    const newOrder = [...currentOrder];
    newOrder.splice(draggedIndex, 1);
    newOrder.splice(targetIndex, 0, draggedColumn);

    onReorderColumns(newOrder);
    setDraggedColumn(null);
  };

  const getPinStatus = (columnId: string) => {
    if (pinnedColumns.left.includes(columnId)) return 'left';
    if (pinnedColumns.right.includes(columnId)) return 'right';
    return false;
  };

  if (!isOpen) return null;

  return (
    <div className="absolute top-full right-0 bg-white border border-gray-200 shadow-lg z-20 w-80 p-4">
      <div className="flex items-center justify-between mb-4">
        <h3 className="text-lg font-semibold">Manage Columns</h3>
        <button onClick={onClose} className="text-gray-500 hover:text-gray-700">
          ‚úï
        </button>
      </div>

      <div className="space-y-2 max-h-96 overflow-y-auto">
        {columns.map((column) => {
          const pinStatus = getPinStatus(column.id);
          const isVisible = visibleColumns.includes(column.id);

          return (
            <div
              key={column.id}
              draggable
              onDragStart={(e) => handleDragStart(e, column.id)}
              onDragOver={handleDragOver}
              onDrop={(e) => handleDrop(e, column.id)}
              className={`
                flex items-center justify-between p-2 border rounded cursor-move
                ${draggedColumn === column.id ? 'bg-blue-100 border-blue-300' : 'hover:bg-gray-50'}
              `}
            >
              <div className="flex items-center space-x-2">
                <span className="text-gray-400 cursor-move">‚ãÆ‚ãÆ</span>
                <input
                  type="checkbox"
                  checked={isVisible}
                  onChange={() => onToggleVisibility(column.id)}
                  className="w-4 h-4 text-blue-600 border-gray-300 rounded focus:ring-blue-500"
                />
                <span className="text-sm font-medium">{column.headerName}</span>
              </div>

              <div className="flex space-x-1">
                <Button
                  variant={pinStatus === 'left' ? 'primary' : 'ghost'}
                  size="sm"
                  onClick={() => onPinColumn(column.id, pinStatus === 'left' ? false : 'left')}
                  className="px-2 py-1 text-xs"
                >
                  üìå‚Üê
                </Button>
                <Button
                  variant={pinStatus === 'right' ? 'primary' : 'ghost'}
                  size="sm"
                  onClick={() => onPinColumn(column.id, pinStatus === 'right' ? false : 'right')}
                  className="px-2 py-1 text-xs"
                >
                  ‚Üíüìå
                </Button>
              </div>
            </div>
          );
        })}
      </div>
    </div>
  );
}

// File: src/components/DataGrid/DataGrid.tsx
import React, { useState, useEffect, useMemo, useRef } from 'react';
import { useDataGrid } from '@/contexts/DataGridContext';
import { DataGridHeader } from './DataGridHeader';
import { DataGridRow } from './DataGridRow';
import { Pagination } from './Pagination';
import { FilterPanel } from './FilterPanel';
import { ColumnManager } from './ColumnManager';
import { Input } from '@/components/ui/Input';
import { Button } from '@/components/ui/Button';
import { Select } from '@/components/ui/Select';
import { useVirtualScroll } from '@/hooks/useVirtualScroll';
import { useLocalStorage } from '@/hooks/useLocalStorage';
import { exportToCSV } from '@/utils/gridHelpers';

interface DataGridProps {
  height?: number;
  checkboxSelection?: boolean;
  onRowClick?: (row: any) => void;
  onRowEdit?: (rowId: string, field: string, value: any) => void;
  className?: string;
}

export function DataGrid({
  height = 600,
  checkboxSelection = false,
  onRowClick,
  onRowEdit,
  className = ''
}: DataGridProps) {
  const { state, actions } = useDataGrid();
  const [showFilters, setShowFilters] = useState(false);
  const [showColumnManager, setShowColumnManager] = useState(false);
  const [searchValue, setSearchValue] = useState('');
  const [preferences, setPreferences] = useLocalStorage('dataGrid_preferences', {});
  const tableRef = useRef<HTMLDivElement>(null);

  // Virtual scrolling setup
  const rowHeight = {
    compact: 32,
    standard: 48,
    comfortable: 64
  }[state.density];

  const containerHeight = height - 120; // Account for header and pagination
  
  const paginatedData = useMemo(() => {
    const start = state.pagination.page * state.pagination.pageSize;
    const end = start + state.pagination.pageSize;
    return state.filteredData.slice(start, end);
  }, [state.filteredData, state.pagination.page, state.pagination.pageSize]);

  const {
    visibleRange,
    totalHeight,
    offsetY,
    setScrollTop
  } = useVirtualScroll({
    itemHeight: rowHeight,
    containerHeight,
    items: paginatedData
  });

  // Get visible columns in correct order
  const visibleColumns = useMemo(() => {
    const orderedColumns = state.columnOrder
      .map(id => state.columns.find(col => col.id === id))
      .filter((col): col is NonNullable<typeof col> => col !== undefined);

    return orderedColumns.filter(col => state.visibleColumns.includes(col.id));
  }, [state.columns, state.visibleColumns, state.columnOrder]);

  // Handle search with debouncing
  useEffect(() => {
    const timer = setTimeout(() => {
      actions.setSearchTerm(searchValue);
    }, 300);

    return () => clearTimeout(timer);
  }, [searchValue, actions]);

  // Save preferences
  useEffect(() => {
    setPreferences({
      visibleColumns: state.visibleColumns,
      columnOrder: state.columnOrder,
      density: state.density,
      pageSize: state.pagination.pageSize
    });
  }, [state.visibleColumns, state.columnOrder, state.density, state.pagination.pageSize, setPreferences]);

  const handleSort = (field: string) => {
    const existingSort = state.sortModel.find(s => s.field === field);
    let newSortModel;

    if (!existingSort) {
      newSortModel = [{ field, sort: 'asc' as const }];
    } else if (existingSort.sort === 'asc') {
      newSortModel = [{ field, sort: 'desc' as const }];
    } else {
      newSortModel = [];
    }

    actions.setSortModel(newSortModel);
  };

  const handleRowClick = (rowId: string) => {
    if (checkboxSelection) {
      actions.toggleRowSelection(rowId);
    }
    
    const row = state.filteredData.find(r => String(r.id) === rowId);
    if (row && onRowClick) {
      onRowClick(row);
    }
  };

  const handleRowEdit = (rowId: string, field: string, value: any) => {
    if (onRowEdit) {
      onRowEdit(rowId, field, value);
    }
  };

  const handleExport = () => {
    const dataToExport = state.selectedRows.size > 0 
      ? state.filteredData.filter(row => state.selectedRows.has(String(row.id)))
      : state.filteredData;
    
    exportToCSV(dataToExport, visibleColumns, 'grid-export.csv');
  };

  const handleColumnMenu = (columnId: string, event: React.MouseEvent) => {
    event.preventDefault();
    // Could implement context menu here
  };

  const handleScroll = (e: React.UIEvent<HTMLDivElement>) => {
    setScrollTop(e.currentTarget.scrollTop);
  };

  const allSelected = state.filteredData.length > 0 && 
    state.filteredData.every(row => state.selectedRows.has(String(row.id)));

  const densityOptions = [
    { value: 'compact', label: 'Compact' },
    { value: 'standard', label: 'Standard' },
    { value: 'comfortable', label: 'Comfortable' }
  ];

  if (state.loading) {
    return (
      <div className={`w-full bg-white border border-gray-200 rounded-lg ${className}`} style={{ height }}>
        <div className="flex items-center justify-center h-full">
          <div className="flex items-center space-x-2">
            <div className="w-6 h-6 border-2 border-blue-600 border-t-transparent rounded-full animate-spin"></div>
            <span className="text-gray-600">Loading...</span>
          </div>
        </div>
      </div>
    );
  }

  if (state.error) {
    return (
      <div className={`w-full bg-white border border-gray-200 rounded-lg ${className}`} style={{ height }}>
        <div className="flex items-center justify-center h-full">
          <div className="text-center">
            <div className="text-red-600 mb-2">‚ö†Ô∏è Error</div>
            <p className="text-gray-600">{state.error}</p>
            <Button 
              className="mt-4" 
              onClick={() => actions.setError(null)}
            >
              Retry
            </Button>
          </div>
        </div>
      </div>
    );
  }

  return (
    <div className={`w-full bg-white border border-gray-200 rounded-lg overflow-hidden ${className}`} style={{ height }}>
      {/* Toolbar */}
      <div className="p-4 border-b border-gray-200 bg-gray-50">
        <div className="flex items-center justify-between">
          <div className="flex items-center space-x-4">
            <Input
              placeholder="Search..."
              value={searchValue}
              onChange={(e) => setSearchValue(e.target.value)}
              className="w-64"
            />
            
            <Button
              variant="ghost"
              onClick={() => setShowFilters(!showFilters)}
            >
              üîç Filters
            </Button>

            <Select
              value={state.density}
              onChange={(e) => actions.setDensity(e.target.value as any)}
              options={densityOptions}
              className="w-32"
            />
          </div>

          <div className="flex items-center space-x-2">
            {state.selectedRows.size > 0 && (
              <>
                <span className="text-sm text-gray-600">
                  {state.selectedRows.size} selected
                </span>
                <Button variant="ghost" size="sm">
                  Delete Selected
                </Button>
              </>
            )}
            
            <Button
              variant="ghost"
              onClick={handleExport}
            >
              üìÅ Export
            </Button>

            <Button
              variant="ghost"
              onClick={() => setShowColumnManager(!showColumnManager)}
            >
              ‚öôÔ∏è Columns
            </Button>
          </div>
        </div>

        {/* Filter Panel */}
        <div className="relative">
          <FilterPanel
            columns={state.columns}
            filterModel={state.filterModel}
            onFilterChange={actions.setFilterModel}
            isOpen={showFilters}
            onClose={() => setShowFilters(false)}
          />
        </div>

        {/* Column Manager */}
        <div className="relative">
          <ColumnManager
            columns={state.columns}
            visibleColumns={state.visibleColumns}
            pinnedColumns={state.pinnedColumns}
            onToggleVisibility={actions.toggleColumnVisibility}
            onPinColumn={actions.pinColumn}
            onReorderColumns={actions.reorderColumns}
            isOpen={showColumnManager}
            onClose={() => setShowColumnManager(false)}
          />
        </div>
      </div>

      {/* Data Grid */}
      <div className="relative overflow-hidden" style={{ height: containerHeight }}>
        <div
          ref={tableRef}
          className="overflow-auto h-full"
          onScroll={handleScroll}
        >
          <table className="w-full border-collapse">
            <DataGridHeader
              columns={visibleColumns}
              sortModel={state.sortModel}
              onSort={handleSort}
              onResize={actions.resizeColumn}
              showCheckbox={checkboxSelection}
              allSelected={allSelected}
              onSelectAll={actions.selectAllRows}
              onColumnMenu={handleColumnMenu}
            />
            <tbody style={{ height: totalHeight, position: 'relative' }}>
              <tr>
                <td colSpan={visibleColumns.length + (checkboxSelection ? 1 : 0)} style={{ height: offsetY }} />
              </tr>
              {visibleRange.visibleItems.map((row, index) => (
                <DataGridRow
                  key={row.id}
                  row={row}
                  columns={visibleColumns}
                  isSelected={state.selectedRows.has(String(row.id))}
                  onRowClick={handleRowClick}
                  onEdit={handleRowEdit}
                  density={state.density}
                  showCheckbox={checkboxSelection}
                />
              ))}
            </tbody>
          </table>
        </div>
      </div>

      {/* Pagination */}
      <Pagination
        pagination={state.pagination}
        onPageChange={(page) => actions.setPagination({ page })}
        onPageSizeChange={(pageSize) => actions.setPagination({ pageSize, page: 0 })}
      />
    </div>
  );
}